{"name":"ActiveInteraction","tagline":"Manage application specific business logic.","body":"<p align=\"center\">\r\n  <img alt=\"\" src=\"https://a.pomf.se/auvctt.svg\" width=\"250\">\r\n</p>\r\n\r\n<p align=\"center\">\r\n  <a href=\"https://rubygems.org/gems/active_interaction\"><img alt=\"\" src=\"https://img.shields.io/gem/v/active_interaction.svg?label=version&amp;style=flat-square\"></a>\r\n  <a href=\"https://travis-ci.org/orgsync/active_interaction\"><img alt=\"\" src=\"https://img.shields.io/travis/orgsync/active_interaction/master.svg?label=build&amp;style=flat-square\"></a>\r\n  <a href=\"https://coveralls.io/r/orgsync/active_interaction\"><img alt=\"\" src=\"https://img.shields.io/coveralls/orgsync/active_interaction/master.svg?label=coverage&amp;style=flat-square\"></a>\r\n  <a href=\"https://codeclimate.com/github/orgsync/active_interaction\"><img alt=\"\" src=\"https://img.shields.io/codeclimate/github/orgsync/active_interaction.svg?label=climate&amp;style=flat-square\"></a>\r\n  <a href=\"https://gemnasium.com/orgsync/active_interaction\"><img alt=\"\" src=\"https://img.shields.io/gemnasium/orgsync/active_interaction.svg?label=dependencies&amp;style=flat-square\"></a>\r\n</p>\r\n\r\n<hr>\r\n\r\nActiveInteraction gives you a place to put your business logic. It also helps\r\nyou write safer code by validating that your inputs conform to your\r\nexpectations. If ActiveModel deals with your nouns, then ActiveInteraction\r\nhandles your verbs.\r\n\r\nRead more on [the project page][] or check out [the full documentation][].\r\n\r\n- [Installation](#installation)\r\n- [Basic usage](#basic-usage)\r\n  - [Validations](#validations)\r\n- [Filters](#filters)\r\n  - [Array](#array)\r\n  - [Boolean](#boolean)\r\n  - [File](#file)\r\n  - [Hash](#hash)\r\n  - [Interface](#interface)\r\n  - [Model](#model)\r\n  - [String](#string)\r\n  - [Symbol](#symbol)\r\n  - [Dates and times](#dates-and-times)\r\n    - [Date](#date)\r\n    - [DateTime](#datetime)\r\n    - [Time](#time)\r\n  - [Numbers](#numbers)\r\n    - [Decimal](#decimal)\r\n    - [Float](#float)\r\n    - [Integer](#integer)\r\n- [Rails](#rails)\r\n  - [Controller](#controller)\r\n    - [Index](#index)\r\n    - [Show](#show)\r\n    - [New](#new)\r\n    - [Create](#create)\r\n    - [Destroy](#destroy)\r\n    - [Edit](#edit)\r\n    - [Update](#update)\r\n  - [Structure](#structure)\r\n- [Advanced usage](#advanced-usage)\r\n  - [Callbacks](#callbacks)\r\n  - [Composition](#composition)\r\n  - [Descriptions](#descriptions)\r\n  - [Errors](#errors)\r\n  - [Forms](#forms)\r\n  - [Predicates](#predicates)\r\n  - [Translations](#translations)\r\n- [Credits](#credits)\r\n\r\n## Installation\r\n\r\nAdd it to your Gemfile:\r\n\r\n``` rb\r\ngem 'active_interaction', '~> 1.5'\r\n```\r\n\r\nOr install it manually:\r\n\r\n``` sh\r\n$ gem install active_interaction --version '~> 1.5'\r\n```\r\n\r\nThis project uses [Semantic Versioning][]. Check out [the change log][] for a\r\ndetailed list of changes.\r\n\r\nActiveInteraction works with all supported versions of Ruby (2.0 through 2.2)\r\nand ActiveModel (3.2 through 4.2).\r\n\r\n## Basic usage\r\n\r\nTo define an interaction, create a subclass of `ActiveInteraction::Base`. Then\r\nyou need to do two things:\r\n\r\n1.  **Define your inputs.** Use class filter methods to define what you expect\r\n    your inputs to look like. For instance, if you need a boolean flag for\r\n    pepperoni, use `boolean :pepperoni`. Check out [the filters\r\n    section](#filters) for all the available options.\r\n\r\n2.  **Define your business logic.** Do this by implementing the `#execute`\r\n    method. Each input you defined will be available as the type you specified.\r\n    If any of the inputs are invalid, `#execute` won't be run. Filters are\r\n    responsible for type checking your inputs. Check out [the validations\r\n    section](#validations) if you need more than that.\r\n\r\nThat covers the basics. Let's put it all together into a simple example that\r\nsquares a number.\r\n\r\n``` rb\r\nrequire 'active_interaction'\r\n\r\nclass Square < ActiveInteraction::Base\r\n  float :x\r\n\r\n  def execute\r\n    x**2\r\n  end\r\nend\r\n```\r\n\r\nCall `.run` on your interaction to execute it. You must pass a single hash to\r\n`.run`. It will return an instance of your interaction. By convention, we call\r\nthis an outcome. You can use the `#valid?` method to ask the outcome if it's\r\nvalid. If it's invalid, take a look at its errors with `#errors`. If it's\r\nvalid, `#result` will be the value returned from `#execute`.\r\n\r\n``` rb\r\noutcome = Square.run(x: 'two point one')\r\noutcome.valid?\r\n# => nil\r\noutcome.errors.messages\r\n# => {:x=>[\"is not a valid float\"]}\r\n\r\noutcome = Square.run(x: 2.1)\r\noutcome.valid?\r\n# => true\r\noutcome.result\r\n# => 4.41\r\n```\r\n\r\nYou can also use `.run!` to execute interactions. It's like `.run` but more\r\ndangerous. It doesn't return an outcome. If the outcome would be invalid, it\r\nwill instead raise an error. But if the outcome would be valid, it simply\r\nreturns the result.\r\n\r\n``` rb\r\nSquare.run!(x: 'two point one')\r\n# ActiveInteraction::InvalidInteractionError: X is not a valid float\r\nSquare.run!(x: 2.1)\r\n# => 4.41\r\n```\r\n\r\n### Validations\r\n\r\nActiveInteraction type checks your inputs. Often you'll want more than that.\r\nFor instance, you may want an input to be a string with at least one\r\nnon-whitespace character. Instead of writing your own validation for that, you\r\ncan use validations from ActiveModel.\r\n\r\nThese validations aren't provided by ActiveInteraction. They're from\r\nActiveModel. You can also use any custom validations you wrote yourself in your\r\ninteractions.\r\n\r\n``` rb\r\nclass SayHello < ActiveInteraction::Base\r\n  string :name\r\n\r\n  validates :name,\r\n    presence: true\r\n\r\n  def execute\r\n    \"Hello, #{name}!\"\r\n  end\r\nend\r\n```\r\n\r\nWhen you run this interaction, two things will happen. First ActiveInteraction\r\nwill type check your inputs. Then ActiveModel will validate them. If both of\r\nthose are happy, it will be executed.\r\n\r\n``` rb\r\nSayHello.run!(name: nil)\r\n# ActiveInteraction::InvalidInteractionError: Name is required\r\n\r\nSayHello.run!(name: '')\r\n# ActiveInteraction::InvalidInteractionError: Name can't be blank\r\n\r\nSayHello.run!(name: 'Taylor')\r\n# => \"Hello, Taylor!\"\r\n```\r\n\r\n## Filters\r\n\r\nYou can define filters inside an interaction using the appropriate class method.\r\nEach method has the same signature:\r\n\r\n- Some symbolic names. These are the attributes to create.\r\n\r\n- An optional hash of options. Each filter supports at least these two options:\r\n\r\n  - `default` is the fallback value to use if `nil` is give. To make a filter\r\n    optional, set `default: nil`.\r\n\r\n  - `desc` is a human-readable description of the input. This can be useful for\r\n    generating documentation. For more information about this, read [the\r\n    descriptions section](#descriptions).\r\n\r\n- An optional block of sub-filters. Only [array](#array) and [hash](#hash)\r\n  filters support this. Other filters will ignore blocks when given to them.\r\n\r\nLet's take a look at an example filter. It defines three inputs: `x`, `y`, and\r\n`z`. Those inputs are optional and they all share the same description (\"an\r\nexample filter\").\r\n\r\n``` rb\r\narray :x, :y, :z,\r\n  default: nil,\r\n  desc: 'an example filter' do\r\n    # Some filters support sub-filters here.\r\n  end\r\n```\r\n\r\nIn general, filters accept values of the type the correspond to, plus a few\r\nalternatives that can be reasonably coerced. Typically the coercions come from\r\nRails, so `\"1\"` can be interpreted as the boolean value `true`, the string\r\n`\"1\"`, or the number `1`.\r\n\r\n### Array\r\n\r\nIn addition to accepting arrays, array inputs will convert\r\n`ActiveRecord::Relation`s into arrays.\r\n\r\n``` rb\r\nclass ArrayInteraction < ActiveInteraction::Base\r\n  array :toppings\r\n\r\n  def execute\r\n    toppings.size\r\n  end\r\nend\r\n\r\nArrayInteraction.run!(toppings: 'everything')\r\n# ActiveInteraction::InvalidInteractionError: Toppings is not a valid array\r\nArrayInteraction.run!(toppings: [:cheese, 'pepperoni'])\r\n# => 2\r\n```\r\n\r\nUse a block to constrain the types of elements an array can contain.\r\n\r\n``` rb\r\narray :birthdays do\r\n  date\r\nend\r\n```\r\n\r\nNote that filters inside an array block don't have names. Also you can only\r\nhave one filter inside an array block.\r\n\r\n### Boolean\r\n\r\nBoolean filters convert the strings `\"1\"` and `\"true\"` (case-insensitive) into\r\n`true`. They also convert `\"0\"` and `\"false\"` into `false`.\r\n\r\n``` rb\r\nclass BooleanInteraction < ActiveInteraction::Base\r\n  boolean :kool_aid\r\n\r\n  def execute\r\n    'Oh yeah!' if kool_aid\r\n  end\r\nend\r\n\r\nBooleanInteraction.run!(kool_aid: 1)\r\n# ActiveInteraction::InvalidInteractionError: Kool aid is not a valid boolean\r\nBooleanInteraction.run!(kool_aid: true)\r\n# => \"Oh yeah!\"\r\n```\r\n\r\n### File\r\n\r\nFile filters also accept `TempFile`s and anything that responds to `#tempfile`.\r\nThat means that you can pass the `params` from uploading files via forms in\r\nRails.\r\n\r\n``` rb\r\nclass FileInteraction < ActiveInteraction::Base\r\n  file :readme\r\n\r\n  def execute\r\n    readme.size\r\n  end\r\nend\r\n\r\nFileInteraction.run!(readme: 'README.md')\r\n# ActiveInteraction::InvalidInteractionError: Readme is not a valid file\r\nFileInteraction.run!(readme: File.open('README.md'))\r\n# => 21563\r\n```\r\n\r\n### Hash\r\n\r\nHash filters accept hashes. The expected value types are given by passing a\r\nblock and nesting other filters. You can have any number of filters inside a\r\nhash, including other hashes.\r\n\r\n``` rb\r\nclass HashInteraction < ActiveInteraction::Base\r\n  hash :preferences do\r\n    boolean :newsletter\r\n    boolean :sweepstakes\r\n  end\r\n\r\n  def execute\r\n    puts 'Thanks for joining the newsletter!' if preferences[:newsletter]\r\n    puts 'Good luck in the sweepstakes!' if preferences[:sweepstakes]\r\n  end\r\nend\r\n\r\nHashInteraction.run!(preferences: 'yes, no')\r\n# ActiveInteraction::InvalidInteractionError: Preferences is not a valid hash\r\nHashInteraction.run!(preferences: { newsletter: true, 'sweepstakes' => false })\r\n# Thanks for joining the newsletter!\r\n# => nil\r\n```\r\n\r\nSetting default hash values can be tricky. The default value has to be either\r\n`nil` or `{}`. Use `nil` to make the hash optional. Use `{}` if you want to set\r\nsome defaults for values inside the hash.\r\n\r\n``` rb\r\nhash :optional,\r\n  default: nil\r\n# => {:optional=>nil}\r\n\r\nhash :with_defaults,\r\n  default: {} do\r\n    boolean :likes_cookies,\r\n      default: true\r\n  end\r\n# => {:with_defaults=>{:likes_cookies=>true}}\r\n```\r\n\r\nBy default, hashes remove any keys that aren't given as nested filters. To\r\nallow all hash keys, set `strip: false`. In general we don't recommend doing\r\nthis, but it's sometimes necessary.\r\n\r\n``` rb\r\nhash :stuff,\r\n  strip: false\r\n```\r\n\r\n### Interface\r\n\r\nInterface filters allow you to specify that an object must respond to a certain\r\nset of methods. This allows you to do duck typing with interactions.\r\n\r\n``` rb\r\nclass InterfaceInteraction < ActiveInteraction::Base\r\n  interface :serializer,\r\n    methods: %i[dump load]\r\n\r\n  def execute\r\n    input = '{ \"is_json\" : true }'\r\n    object = serializer.load(input)\r\n    output = serializer.dump(object)\r\n\r\n    output\r\n  end\r\nend\r\n\r\nrequire 'json'\r\n\r\nInterfaceInteraction.run!(serializer: Object.new)\r\n# ActiveInteraction::InvalidInteractionError: Serializer is not a valid interface\r\nInterfaceInteraction.run!(serializer: JSON)\r\n# => \"{\\\"is_json\\\":true}\"\r\n```\r\n\r\n### Model\r\n\r\nModel filters allow you to require an instance of a particular class. It checks\r\neither `#is_a?` on the instance or `.===` on the class. Because of that, it\r\nalso works with classes that have mixed modules in with `include`.\r\n\r\n``` rb\r\nclass Cow\r\n  def moo\r\n    'Moo!'\r\n  end\r\nend\r\n\r\nclass ModelInteraction < ActiveInteraction::Base\r\n  model :cow\r\n\r\n  def execute\r\n    cow.moo\r\n  end\r\nend\r\n\r\nModelInteraction.run!(cow: Object.new)\r\n# ActiveInteraction::InvalidInteractionError: Cow is not a valid model\r\nModelInteraction.run!(cow: Cow.new)\r\n# => \"Moo!\"\r\n```\r\n\r\nThe class name is automatically determined by the filter name. If your filter\r\nname is different than your class name, use the `class` option. It can be\r\neither the class, a string, or a symbol.\r\n\r\n``` rb\r\nmodel :dolly1,\r\n  class: Sheep\r\nmodel :dolly2,\r\n  class: 'Sheep'\r\nmodel :dolly3,\r\n  class: :Sheep\r\n```\r\n\r\n### String\r\n\r\nString filters define inputs that only accept strings.\r\n\r\n``` rb\r\nclass StringInteraction < ActiveInteraction::Base\r\n  string :name\r\n\r\n  def execute\r\n    \"Hello, #{name}!\"\r\n  end\r\nend\r\n\r\nStringInteraction.run!(name: 0xDEADBEEF)\r\n# ActiveInteraction::InvalidInteractionError: Name is not a valid string\r\nStringInteraction.run!(name: 'Taylor')\r\n# => \"Hello, Taylor!\"\r\n```\r\n\r\nIf you want to strip leading and trailing whitespace from a string, set the\r\n`strip` option to `true`.\r\n\r\n``` rb\r\nstring :comment,\r\n  strip: true\r\n```\r\n\r\n### Symbol\r\n\r\nSymbol filters define inputs that accept symbols. Strings will be converted\r\ninto symbols.\r\n\r\n``` rb\r\nclass SymbolInteraction < ActiveInteraction::Base\r\n  symbol :method\r\n\r\n  def execute\r\n    method.to_proc\r\n  end\r\nend\r\n\r\nSymbolInteraction.run!(method: -> {})\r\n# ActiveInteraction::InvalidInteractionError: Method is not a valid symbol\r\nSymbolInteraction.run!(method: :object_id)\r\n# => #<Proc:0x007fdc9ba94118>\r\n```\r\n\r\n### Dates and times\r\n\r\nFilters that work with dates and times behave similarly. By default, they all\r\nconvert strings into their expected data types using `.parse`. If you give the\r\n`format` option, they will instead convert strings using `.strptime`. Note that\r\nformats won't work with `DateTime` and `Time` filters if a time zone is set.\r\n\r\n#### Date\r\n\r\n``` rb\r\nclass DateInteraction < ActiveInteraction::Base\r\n  date :birthday\r\n\r\n  def execute\r\n    birthday + (18 * 365)\r\n  end\r\nend\r\n\r\nDateInteraction.run!(birthday: 'yesterday')\r\n# ActiveInteraction::InvalidInteractionError: Birthday is not a valid date\r\nDateInteraction.run!(birthday: Date.new(1989, 9, 1))\r\n# => #<Date: 2007-08-28 ((2454341j,0s,0n),+0s,2299161j)>\r\n```\r\n\r\n``` rb\r\ndate :birthday,\r\n  format: '%Y-%m-%d'\r\n```\r\n\r\n#### DateTime\r\n\r\n``` rb\r\nclass DateTimeInteraction < ActiveInteraction::Base\r\n  date_time :now\r\n\r\n  def execute\r\n    now.iso8601\r\n  end\r\nend\r\n\r\nDateTimeInteraction.run!(now: 'now')\r\n# ActiveInteraction::InvalidInteractionError: Now is not a valid date time\r\nDateTimeInteraction.run!(now: DateTime.now)\r\n# => \"2015-03-11T11:04:40-05:00\"\r\n```\r\n\r\n``` rb\r\ndate_time :start,\r\n  format: '%Y-%m-%dT%H:%M:%S'\r\n```\r\n\r\n#### Time\r\n\r\nIn addition to converting strings with `.parse` (or `.strptime`), time filters\r\nconvert numbers with `.at`.\r\n\r\n``` rb\r\nclass TimeInteraction < ActiveInteraction::Base\r\n  time :epoch\r\n\r\n  def execute\r\n    Time.now - epoch\r\n  end\r\nend\r\n\r\nTimeInteraction.run!(epoch: 'a long, long time ago')\r\n# ActiveInteraction::InvalidInteractionError: Epoch is not a valid time\r\nTimeInteraction.run!(epoch: Time.new(1970))\r\n# => 1426068362.5136619\r\n```\r\n\r\n``` rb\r\ntime :start,\r\n  format: '%Y-%m-%dT%H:%M:%S'\r\n```\r\n\r\n### Numbers\r\n\r\nAll numeric filters accept numeric input. They will also convert strings using\r\nthe appropriate method from `Kernel` (like `.Float`).\r\n\r\n#### Decimal\r\n\r\n``` rb\r\nclass DecimalInteraction < ActiveInteraction::Base\r\n  decimal :price\r\n\r\n  def execute\r\n    price * 1.0825\r\n  end\r\nend\r\n\r\nDecimalInteraction.run!(price: 'one ninety-nine')\r\n# ActiveInteraction::InvalidInteractionError: Price is not a valid decimal\r\nDecimalInteraction.run!(price: BigDecimal.new(1.99, 2))\r\n# => #<BigDecimal:7fe792a42028,'0.2165E1',18(45)>\r\n```\r\n\r\nTo specify the number of significant digits, use the `digits` option.\r\n\r\n``` rb\r\ndecimal :dollars,\r\n  digits: 2\r\n```\r\n\r\n#### Float\r\n\r\n``` rb\r\nclass FloatInteraction < ActiveInteraction::Base\r\n  float :x\r\n\r\n  def execute\r\n    x**2\r\n  end\r\nend\r\n\r\nFloatInteraction.run!(x: 'two point one')\r\n# ActiveInteraction::InvalidInteractionError: X is not a valid float\r\nFloatInteraction.run!(x: 2.1)\r\n# => 4.41\r\n```\r\n\r\n#### Integer\r\n\r\n``` rb\r\nclass IntegerInteraction < ActiveInteraction::Base\r\n  integer :limit\r\n\r\n  def execute\r\n    limit.downto(0).to_a\r\n  end\r\nend\r\n\r\nIntegerInteraction.run!(limit: 'ten')\r\n# ActiveInteraction::InvalidInteractionError: Limit is not a valid integer\r\nIntegerInteraction.run!(limit: 10)\r\n# => [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\r\n```\r\n\r\n## Rails\r\n\r\nActiveInteraction plays nicely with Rails. You can use interactions to handle\r\nyour business logic instead of models or controllers. To see how it all works,\r\nlet's take a look at a complete example of a controller with the typical\r\nresourceful actions.\r\n\r\n### Controller\r\n\r\n#### Index\r\n\r\n``` rb\r\n# GET /accounts\r\ndef index\r\n  @accounts = ListAccounts.run!\r\nend\r\n```\r\n\r\nSince we're not passing any inputs to `ListAccounts`, it makes sense to use\r\n`.run!` instead of `.run`. If it failed, that would mean we probably messed up\r\nwriting the interaction.\r\n\r\n``` rb\r\nclass ListAccounts < ActiveInteraction::Base\r\n  def execute\r\n    Account.not_deleted.order(last_name: :asc, first_name: :asc)\r\n  end\r\nend\r\n```\r\n\r\n#### Show\r\n\r\nUp next is the show action. For this one we'll define a helper method to handle\r\nraising the correct errors. We have to do this because calling `.run!` would\r\nraise an `ActiveInteraction::InvalidInteractionError` instead of an\r\n`ActiveRecord::RecordNotFound`. That means Rails would render a 500 instead of\r\na 404.\r\n\r\n``` rb\r\n# GET /accounts/:id\r\ndef show\r\n  @account = find_account!\r\nend\r\n\r\nprivate\r\n\r\ndef find_account!\r\n  outcome = FindAccount.run(params)\r\n\r\n  if outcome.valid?\r\n    outcome.result\r\n  else\r\n    fail ActiveRecord::RecordNotFound, outcome.errors.full_messages.to_sentence\r\n  end\r\nend\r\n```\r\n\r\nThis probably looks a little different than you're used to. Rails commonly\r\nhandles this with a `before_filter` that sets the `@account` instance variable.\r\nWhy is all this interaction code better? Two reasons: One, you can reuse the\r\n`FindAccount` interaction in other places, like your API controller or a Resque\r\ntask. And two, if you want to change how accounts are found, you only have to\r\nchange one place.\r\n\r\nInside the interaction, we could use `#find` instead of `#find_by_id`. That way\r\nwe wouldn't need the `#find_account!` helper method in the controller because\r\nthe error would bubble all the way up. However, you should try to avoid raising\r\nerrors from interactions. If you do, you'll have to deal with raised exceptions\r\nas well as the validity of the outcome.\r\n\r\n``` rb\r\nclass FindAccount < ActiveInteraction::Base\r\n  integer :id\r\n\r\n  def execute\r\n    account = Account.not_deleted.find_by_id(id)\r\n\r\n    if account\r\n      account\r\n    else\r\n      errors.add(:id, 'does not exist')\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nNote that it's perfectly fine to add errors during execution. Not all errors\r\nhave to come from type checking or validation.\r\n\r\n#### New\r\n\r\nThe new action will be a little different than the ones we've looked at so far.\r\nInstead of calling `.run` or `.run!`, it's going to initialize a new\r\ninteraction. This is possible because interactions behave like ActiveModels.\r\n\r\n``` rb\r\n# GET /accounts/new\r\ndef new\r\n  @account = CreateAccount.new\r\nend\r\n```\r\n\r\nSince interactions behave like ActiveModels, we can use ActiveModel validations\r\nwith them. We'll use validations here to make sure that the first and last\r\nnames are not blank. [The validations section](#validations) goes into more\r\ndetail about this.\r\n\r\n``` rb\r\nclass CreateAccount < ActiveInteraction::Base\r\n  string :first_name, :last_name\r\n\r\n  validates :first_name, :last_name,\r\n    presence: true\r\n\r\n  def to_model\r\n    Account.new\r\n  end\r\n\r\n  def execute\r\n    account = Account.new(inputs)\r\n\r\n    unless account.save\r\n      errors.merge!(account.errors)\r\n    end\r\n\r\n    account\r\n  end\r\nend\r\n```\r\n\r\nWe used a couple of advanced features here. The `#to_model` method helps\r\ndetermine the correct form to use in the view. Check out [the section on\r\nforms](#forms) for more about that. Inside `#execute`, we merge errors. This is\r\na convenient way to move errors from one object to another. Read more about it\r\nin [the errors section](#errors).\r\n\r\n#### Create\r\n\r\nThe create action has a lot in common with the new action. Both of them use the\r\n`CreateAccount` interaction. And if creating the account fails, this action\r\nfalls back to rendering the new action.\r\n\r\n``` rb\r\n# POST /accounts\r\ndef create\r\n  outcome = CreateAccount.run(params.fetch(:account, {}))\r\n\r\n  if outcome.valid?\r\n    redirect_to(outcome.result)\r\n  else\r\n    @account = outcome\r\n    render(:new)\r\n  end\r\nend\r\n```\r\n\r\nNote that we have to pass a hash to `.run`. Passing `nil` is an error.\r\n\r\nSince we're using an interaction, we don't need strong parameters. The\r\ninteraction will ignore any inputs that weren't defined by filters. So you can\r\nforget about `params.require` and `params.permit` because interactions handle\r\nthat for you.\r\n\r\n#### Destroy\r\n\r\nThe destroy action will reuse the `#find_account!` helper method we wrote\r\nearlier.\r\n\r\n``` rb\r\n# DELETE /accounts/:id\r\ndef destroy\r\n  DestroyAccount.run!(account: find_account!)\r\n  redirect_to(accounts_url)\r\nend\r\n```\r\n\r\nIn this simple example, the destroy interaction doesn't do much. It's not clear\r\nthat you gain anything by putting it in an interaction. But in the future, when\r\nyou need to do more than `account.destroy`, you'll only have to update one\r\nspot.\r\n\r\n``` rb\r\nclass DestroyAccount < ActiveInteraction::Base\r\n  model :account\r\n\r\n  def execute\r\n    account.destroy\r\n  end\r\nend\r\n```\r\n\r\n#### Edit\r\n\r\nJust like the destroy action, editing uses the `#find_account!` helper. Then it\r\ncreates a new interaction instance to use as a form object.\r\n\r\n``` rb\r\n# GET /accounts/:id/edit\r\ndef edit\r\n  account = find_account!\r\n  @account = UpdateAccount.new(\r\n    account: account,\r\n    first_name: account.first_name,\r\n    last_name: account.last_name)\r\nend\r\n```\r\n\r\nThe interaction that updates accounts is more complicated than the others. It\r\nrequires an account to update, but the other inputs are optional. If they're\r\nmissing, it'll ignore those attributes. If they're present, it'll update them.\r\n\r\nActiveInteraction generates predicate methods (like `#first_name?`) for your\r\ninputs. They will return `false` if the input is `nil` and `true` otherwise.\r\nSkip to [the predicates section](#predicates) for more information about them.\r\n\r\n``` rb\r\nclass UpdateAccount < ActiveInteraction::Base\r\n  model :account\r\n\r\n  string :first_name, :last_name,\r\n    default: nil\r\n\r\n  validates :first_name,\r\n    presence: true,\r\n    if: :first_name?\r\n  validates :last_name,\r\n    presence: true,\r\n    if: :last_name?\r\n\r\n  def execute\r\n    account.first_name = first_name if first_name?\r\n    account.last_name = last_name if last_name?\r\n\r\n    unless account.save\r\n      errors.merge!(account.errors)\r\n    end\r\n\r\n    account\r\n  end\r\nend\r\n```\r\n\r\n#### Update\r\n\r\nHopefully you've gotten the hang of this by now. We'll use `#find_account!` to\r\nget the account. Then we'll build up the inputs for `UpdateAccount`. Then we'll\r\nrun the interaction and either redirect to the updated account or back to the\r\nedit page.\r\n\r\n``` rb\r\n# PUT /accounts/:id\r\ndef update\r\n  inputs = { account: find_account! }.reverse_merge(params[:account])\r\n  outcome = UpdateAccount.run(inputs)\r\n\r\n  if outcome.valid?\r\n    redirect_to(outcome.result)\r\n  else\r\n    @account = outcome\r\n    render(:edit)\r\n  end\r\nend\r\n```\r\n\r\n### Structure\r\n\r\nWe recommend putting your interactions in `app/interactions`. It's also very\r\nhelpful to group them by model. That way you can look in\r\n`app/interactions/accounts` for all the ways you can interact with accounts.\r\n\r\n```\r\n- app/\r\n  - controllers/\r\n    - accounts_controller.rb\r\n  - interactions/\r\n    - accounts/\r\n      - create_account.rb\r\n      - destroy_account.rb\r\n      - find_account.rb\r\n      - list_accounts.rb\r\n      - update_account.rb\r\n  - models/\r\n    - account.rb\r\n  - views/\r\n    - account/\r\n      - edit.html.erb\r\n      - index.html.erb\r\n      - new.html.erb\r\n      - show.html.erb\r\n```\r\n\r\n## Advanced usage\r\n\r\n### Callbacks\r\n\r\nActiveModel provides a powerful framework for defining callbacks.\r\nActiveInteraction hooks into that framework to allow hooking into various parts\r\nof an interaction's lifecycle.\r\n\r\n``` rb\r\nclass Increment < ActiveInteraction::Base\r\n  set_callback :type_check, :before, -> { puts 'before type check' }\r\n\r\n  integer :x\r\n\r\n  set_callback :validate, :after, -> { puts 'after validate' }\r\n\r\n  validates :x,\r\n    numericality: { greater_than_or_equal_to: 0 }\r\n\r\n  set_callback :execute, :around, lambda { |_interaction, block|\r\n    puts '>>>'\r\n    block.call\r\n    puts '<<<'\r\n  }\r\n\r\n  def execute\r\n    puts 'executing'\r\n    x + 1\r\n  end\r\nend\r\n\r\nIncrement.run!(x: 1)\r\n# before type check\r\n# after validate\r\n# >>>\r\n# executing\r\n# <<<\r\n# => 2\r\n```\r\n\r\nIn order, the available callbacks are `type_check`, `validate`, and `execute`.\r\nYou can set `before`, `after`, or `around` on any of them.\r\n\r\n### Composition\r\n\r\nYou can run interactions from within other interactions with `#compose`. If the\r\ninteraction is successful, it'll return the result (just like if you had called\r\nit with `.run!`). If something went wrong, execution will halt immediately and\r\nthe errors will be moved onto the caller.\r\n\r\n``` rb\r\nclass Add < ActiveInteraction::Base\r\n  integer :x, :y\r\n\r\n  def execute\r\n    x + y\r\n  end\r\nend\r\n\r\nclass AddThree < ActiveInteraction::Base\r\n  integer :x\r\n\r\n  def execute\r\n    compose(Add, x: x, y: 3)\r\n  end\r\nend\r\n\r\nAddThree.run!(x: 5)\r\n# => 8\r\n```\r\n\r\nTo bring in filters from another interaction, use `.import_filters`. Combined\r\nwith `inputs`, delegating to another interaction is a piece of cake.\r\n\r\n``` rb\r\nclass AddAndDouble < ActiveInteraction::Base\r\n  import_filters Add\r\n\r\n  def execute\r\n    compose(Add, inputs) * 2\r\n  end\r\nend\r\n```\r\n\r\n### Descriptions\r\n\r\nUse the `desc` option to provide human-readable descriptions of filters. You\r\nshould prefer these to comments because they can be used to generate\r\ndocumentation. The interaction class has a `.filters` method that returns a\r\nhash of filters. Each filter has a `#desc` method that returns the description.\r\n\r\n``` rb\r\nclass Descriptive < ActiveInteraction::Base\r\n  string :first_name,\r\n    desc: 'your first name'\r\n  string :last_name,\r\n    desc: 'your last name'\r\nend\r\n\r\nDescriptive.filters.each do |name, filter|\r\n  puts \"#{name}: #{filter.desc}\"\r\nend\r\n# first_name: your first name\r\n# last_name: your last name\r\n```\r\n\r\n### Errors\r\n\r\nActiveInteraction provides symbolic errors for easier introspection and testing\r\nof errors. Symbolic errors improve on regular errors by adding a symbol that\r\nrepresents the type of error that has occurred. Let's look at an example where\r\nan item is purchased using a credit card.\r\n\r\n``` rb\r\nclass BuyItem < ActiveInteraction::Base\r\n  model :credit_card, :item\r\n  hash :options do\r\n    boolean :gift_wrapped\r\n  end\r\n\r\n  def execute\r\n    order = credit_card.purchase(item)\r\n    notify(credit_card.account)\r\n    order\r\n  end\r\n\r\n  private def notify(account)\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nHaving missing or invalid inputs causes the interaction to fail and return\r\nerrors.\r\n\r\n``` rb\r\noutcome = BuyItem.run(item: 'Thing', options: { gift_wrapped: 'yes' })\r\noutcome.errors.messages\r\n# => {:credit_card=>[\"is required\"], :item=>[\"is not a valid model\"], :options=>[\"has an invalid nested value (\\\"gift_wrapped\\\" => \\\"yes\\\")\"]}\r\n```\r\n\r\nDetermining the type of error based on the string is difficult if not\r\nimpossible. Calling `#symbolic` instead of `#messages` on `errors` gives you\r\nthe same list of errors with a testable label representing the error.\r\n\r\n``` rb\r\noutcome.errors.symbolic\r\n# => {\"credit_card\"=>[:missing], \"item\"=>[:invalid_type], \"options\"=>[:invalid_nested]}\r\n```\r\n\r\nSymbolic errors can also be manually added during the execute call by calling\r\n`#add_sym` instead of `#add` on `errors`. It works the same way as `add` except\r\nthat the second argument is the error label.\r\n\r\n``` rb\r\ndef execute\r\n  errors.add_sym(:monster, :no_passage, 'You shall not pass!')\r\nend\r\n```\r\n\r\nActiveInteraction also supports merging errors. This is useful if you want to\r\ndelegate validation to some other object. For example, if you have an\r\ninteraction that updates a record, you might want that record to validate\r\nitself. By using the `#merge!` helper on `errors`, you can do exactly that.\r\n\r\n``` rb\r\nclass UpdateThing < ActiveInteraction::Base\r\n  model :thing\r\n\r\n  def execute\r\n    unless thing.save\r\n      errors.merge!(thing.errors)\r\n    end\r\n\r\n    thing\r\n  end\r\nend\r\n```\r\n\r\n### Forms\r\n\r\nThe outcome returned by `.run` can be used in forms as though it were an ActiveModel object. You can also create a form object by calling `.new` on the interaction.\r\n\r\nGiven an application with an `Account` model we'll create a new `Account` using the `CreateAccount` interaction.\r\n\r\n```rb\r\n# GET /accounts/new\r\ndef new\r\n  @account = CreateAccount.new\r\nend\r\n\r\n# POST /accounts\r\ndef create\r\n  outcome = CreateAccount.run(params.fetch(:account, {}))\r\n\r\n  if outcome.valid?\r\n    redirect_to(outcome.result)\r\n  else\r\n    @account = outcome\r\n    render(:new)\r\n  end\r\nend\r\n```\r\n\r\nThe form used to create a new `Account` has slightly more information on the `form_for` call than you might expect.\r\n\r\n```rb\r\n<%= form_for @account, as: :account, url: accounts_path do |f| %>\r\n  <%= f.text_field :first_name %>\r\n  <%= f.text_field :last_name %>\r\n  <%= f.submit 'Create' %>\r\n<% end %>\r\n```\r\n\r\nThis is necessary because we want the form to act like it is creating a new `Account`. Defining `to_model` on the `CreateAccount` interaction tells the form to treat our interaction like an `Account`.\r\n\r\n```rb\r\nclass CreateAccount < ActiveInteraction::Base\r\n  ...\r\n\r\n  def to_model\r\n    Account.new\r\n  end\r\nend\r\n```\r\n\r\nNow our `form_for` call knows how to generate the correct URL and param name (i.e. `params[:account]`).\r\n\r\n```rb\r\n# app/views/accounts/new.html.erb\r\n<%= form_for @account do |f| %>\r\n  ...\r\n<% end %>\r\n```\r\n\r\nActiveInteraction also supports [formtastic][] and [simple_form][]. The filters used to define the inputs on your interaction will relay type information to these gems. As a result, form fields will automatically use the appropriate input type.\r\n\r\n### Predicates\r\n\r\nActiveInteraction creates a predicate method for every input defined by a filter. So if you have an input called `foo`, there will be a predicate method called `#foo?`. That method will tell you if the input was given (that is, if it was not `nil`).\r\n\r\n``` rb\r\nclass SayHello < ActiveInteraction::Base\r\n  string :name,\r\n    default: nil\r\n\r\n  def execute\r\n    if name?\r\n      \"Hello, #{name}!\"\r\n    else\r\n      \"Howdy, stranger!\"\r\n    end\r\n  end\r\nend\r\n\r\nSayHello.run!(name: nil)\r\n# => \"Howdy, stranger!\"\r\nSayHello.run!(name: 'Taylor')\r\n# => \"Hello, Taylor!\"\r\n```\r\n\r\n### Translations\r\n\r\nActiveInteraction is i18n aware out of the box! All you have to do is add\r\ntranslations to your project. In Rails, these typically go into\r\n`config/locales`. For example, let's say that for some reason you want to print\r\neverything out backwards. Simply add translations for ActiveInteraction to your\r\n`hsilgne` locale.\r\n\r\n``` yml\r\n# config/locales/hsilgne.yml\r\nhsilgne:\r\n  active_interaction:\r\n    types:\r\n      array: yarra\r\n      boolean: naeloob\r\n      date: etad\r\n      date_time: emit etad\r\n      decimal: lamiced\r\n      file: elif\r\n      float: taolf\r\n      hash: hsah\r\n      integer: regetni\r\n      interface: ecafretni\r\n      model: ledom\r\n      string: gnirts\r\n      symbol: lobmys\r\n      time: emit\r\n    errors:\r\n      messages:\r\n        invalid: dilavni si\r\n        invalid_nested: (%{value} <= %{name}) eulav detsen dilavni na sah\r\n        invalid_type: '%{type} dilav a ton si'\r\n        missing: deriuqer si\r\n```\r\n\r\nThen set your locale and run interactions like normal.\r\n\r\n``` rb\r\nclass I18nInteraction < ActiveInteraction::Base\r\n  string :name\r\nend\r\n\r\nI18nInteraction.run(name: false).errors.messages[:name]\r\n# => [\"is not a valid string\"]\r\n\r\nI18n.locale = :hsilgne\r\nI18nInteraction.run(name: false).errors.messages[:name]\r\n# => [\"gnirts dilav a ton si\"]\r\n```\r\n\r\n## Credits\r\n\r\nActiveInteraction is brought to you by [Aaron Lasseigne][] and\r\n[Taylor Fausak][] from [OrgSync][]. We were inspired by the fantastic work done\r\nby [Jonathan Novak][] on [Mutations][].\r\n\r\nIf you want to contribute to ActiveInteraction, please read\r\n[our contribution guidelines][]. A [complete list of contributors][] is\r\navailable on GitHub.\r\n\r\nActiveInteraction is licensed under [the MIT License][].\r\n\r\nLogo design by [Tyler Lee][].\r\n\r\n[the project page]: http://orgsync.github.io/active_interaction/\r\n[the full documentation]: http://rubydoc.info/github/orgsync/active_interaction\r\n[semantic versioning]: http://semver.org/spec/v2.0.0.html\r\n[the change log]: CHANGELOG.md\r\n[aaron lasseigne]: https://github.com/AaronLasseigne\r\n[taylor fausak]: https://github.com/tfausak\r\n[orgsync]: https://github.com/orgsync\r\n[jonathan novak]: https://github.com/cypriss\r\n[mutations]: https://github.com/cypriss/mutations\r\n[our contribution guidelines]: CONTRIBUTING.md\r\n[complete list of contributors]: https://github.com/orgsync/active_interaction/graphs/contributors\r\n[the mit license]: LICENSE.txt\r\n[formtastic]: https://rubygems.org/gems/formtastic\r\n[simple_form]: https://rubygems.org/gems/simple_form\r\n[tyler lee]: https://github.com/tylerlee\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}